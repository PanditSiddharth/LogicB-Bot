// ============================================
// OPTIMIZED AUTO-MODERATION UI COMPONENTS
// functions/bot/automod_ui_components.ts
// ============================================

import { BotHelpers } from '../utils/helpers';
import { MessageManager } from '../utils/messageManager';

export interface UIComponent {
  message: string;
  keyboard: {
    inline_keyboard: Array<Array<{
      text: string;
      callback_data: string;
    }>>;
  };
}

export class AutoModUIComponents {
  // ============================================
  // MAIN UPDATE METHOD
  // ============================================
  static async updateUI(ctx: any, settings: any, section: string) {
    try {
      const component = await this.getComponent(settings, section);
      await MessageManager.updateUI(ctx, `automod_${section}`, component);
      
      if (ctx.callbackQuery) {
        await ctx.answerCbQuery().catch(() => {});
      }
    } catch (error) {
      console.error('UI Update Error:', error);
      if (ctx.callbackQuery) {
        await ctx.answerCbQuery('‚ùå Error updating UI', true).catch(() => {});
      }
    }
  }

  // ============================================
  // COMPONENT ROUTER
  // ============================================
  static async getComponent(settings: any, section: string): Promise<UIComponent> {
    const componentMap: Record<string, () => UIComponent> = {
      'automod_words': () => this.getBannedWordsUI(settings),
      'automod_spam': () => this.getAntiSpamUI(settings),
      'automod_flood': () => this.getAntiFloodUI(settings),
      'automod_media': () => this.getMediaFilterUI(settings),
      'automod_multijoin': () => this.getMultiJoinUI(settings),
      'automod_warnings': () => this.getWarningSystemUI(settings),
      'automod_autodelete': () => this.getAutoDeleteUI(settings),
      'automod_reports': () => this.getReportsUI(settings),
      'automod_newusers': () => this.getNewUsersUI(settings),
      'back_automod': () => this.getDashboardUI(settings, '')
    };

    const component = componentMap[section];
    return component ? component() : this.getDashboardUI(settings, '');
  }

  // ============================================
  // DASHBOARD
  // ============================================
  private static getDashboardUI(settings: any, communityName: string): UIComponent {
    const s = settings; // Shorthand
    const enabled = (field: any) => field?.enabled ? '‚úÖ' : '‚ùå';
    
    const message = `
‚öôÔ∏è *Auto-Moderation Dashboard*

*Current Status:*
${enabled(s.bannedWords)} Banned Words (${s.bannedWords?.words?.length || 0} words)
${enabled(s.antiSpam)} Anti-Spam
${enabled(s.antiFlood)} Anti-Flood
${enabled(s.mediaRestrictions)} Media Restrictions
${enabled(s.multiJoinDetection)} Multi-Join Detection
${enabled(s.warningSystem)} Warning System
${enabled(s.autoDelete)} Auto-Delete
${enabled(s.reportSettings)} Reports

*Click buttons to configure:*
    `;

    const keyboard = {
      inline_keyboard: [
        [
          { text: "üö´ Banned Words", callback_data: "automod_words" },
          { text: "üìä Anti-Spam", callback_data: "automod_spam" }
        ],
        [
          { text: "üåä Anti-Flood", callback_data: "automod_flood" },
          { text: "üé¨ Media Filter", callback_data: "automod_media" }
        ],
        [
          { text: "üë• Multi-Join", callback_data: "automod_multijoin" },
          { text: "‚ö†Ô∏è Warnings", callback_data: "automod_warnings" }
        ],
        [
          { text: "üóëÔ∏è Auto-Delete", callback_data: "automod_autodelete" },
          { text: "üì¢ Reports", callback_data: "automod_reports" }
        ],
        [
          { text: "üÜï New Users", callback_data: "automod_newusers" },
          
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // BANNED WORDS
  // ============================================
  private static getBannedWordsUI(settings: any): UIComponent {
    const words = settings?.bannedWords?.words || [];
    const wordsList = words.length > 0 
      ? words.slice(0, 10).join(', ') + (words.length > 10 ? '...' : '')
      : 'No words added';

    const message = `
üö´ *Banned Words Filter*

*Status:* ${settings?.bannedWords?.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}
*Total Words:* ${words.length}
*Action:* ${settings?.bannedWords?.action || 'warn'}
*Warnings Before Punish:* ${settings?.bannedWords?.warningsBeforePunish || 3}

*Words:* ${wordsList}

*Commands:*
\`/addword spam scam\` - Add words
\`/removeword spam\` - Remove word
\`/listwords\` - View all words
\`/wordaction ban\` - Set action
\`/wordwarnings 3\` - Set warnings
\`/togglewords\` - Enable/Disable

*Actions:* delete | warn | mute | kick | ban`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: settings?.bannedWords?.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_words" }
        ],
        [
          { text: "üîô Back", callback_data: "back_automod" },
          { text: "‚ùå Close", callback_data: "close" }        
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // ANTI-SPAM
  // ============================================
  private static getAntiSpamUI(settings: any): UIComponent {
    const spam = settings?.antiSpam || {};
    
    const message = `
üìä *Anti-Spam Protection*

*Status:* ${spam.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Configuration:*
‚Ä¢ Max Messages: ${spam.maxMessages || 5}
‚Ä¢ Time Window: ${spam.timeWindow || 10} seconds
‚Ä¢ Action: ${spam.action?.toUpperCase() || 'MUTE'}
‚Ä¢ Mute Duration: ${BotHelpers.formatDuration(spam.muteDuration || 3600)}

*How it Works:*
If user sends more than ${spam.maxMessages || 5} messages in ${spam.timeWindow || 10} seconds, they will be ${spam.action || 'muted'}.

*Commands:*
\`/antispam_toggle\` - Enable/Disable
\`/antispam_limit 5\` - Set max messages
\`/antispam_window 10\` - Time window`;

    const actionButtons = [
      { text: `${spam.action === 'warn' ? '‚úÖ' : ''} Warn`, callback_data: 'set_action_antispam_warn' },
      { text: `${spam.action === 'mute' ? '‚úÖ' : ''} Mute`, callback_data: 'set_action_antispam_mute' },
      { text: `${spam.action === 'kick' ? '‚úÖ' : ''} Kick`, callback_data: 'set_action_antispam_kick' },
      { text: `${spam.action === 'ban' ? '‚úÖ' : ''} Ban`, callback_data: 'set_action_antispam_ban' }
    ];

    const durationButtons = spam.action === 'mute' ? [
      { text: '1h', callback_data: 'set_duration_antispam_3600' },
      { text: '6h', callback_data: 'set_duration_antispam_21600' },
      { text: '12h', callback_data: 'set_duration_antispam_43200' },
      { text: '24h', callback_data: 'set_duration_antispam_86400' }
    ] : [];

    const keyboard = {
      inline_keyboard: [
        [
          { text: spam.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_antispam" }
        ],
        actionButtons,
        ...durationButtons.length > 0 ? [durationButtons] : [],
        [
          { text: "üîô Back to Auto-Mod", callback_data: "back_automod" },
          { text: "‚ùå Close", callback_data: "close" }
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // ANTI-FLOOD
  // ============================================
  private static getAntiFloodUI(settings: any): UIComponent {
    const flood = settings?.antiFlood || {};
    
    const message = `
üåä *Anti-Flood Protection*

*Status:* ${flood.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Configuration:*
‚Ä¢ Max Repeats: ${flood.maxRepeats || 3}
‚Ä¢ Action: ${flood.action?.toUpperCase() || 'MUTE'}

*How it Works:*
If user sends the same message ${flood.maxRepeats || 3} times, they will be ${flood.action || 'muted'}.

*Example:*
User sends "spam spam spam" ‚Üí Action triggered

*Commands:*
\`/antiflood_toggle\` - Enable/Disable
\`/antiflood_limit 3\` - Set max repeats`;

    const actionButtons = [
      { text: `${flood.action === 'warn' ? '‚úÖ' : ''} Warn`, callback_data: 'set_action_antiflood_warn' },
      { text: `${flood.action === 'mute' ? '‚úÖ' : ''} Mute`, callback_data: 'set_action_antiflood_mute' },
      { text: `${flood.action === 'kick' ? '‚úÖ' : ''} Kick`, callback_data: 'set_action_antiflood_kick' },
      { text: `${flood.action === 'ban' ? '‚úÖ' : ''} Ban`, callback_data: 'set_action_antiflood_ban' }
    ];

    const keyboard = {
      inline_keyboard: [
        [
          { text: flood.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_antiflood" }
        ],
        actionButtons,
        [
          { text: "üîô Back to Auto-Mod", callback_data: "back_automod" },
          { text: "‚ùå Close", callback_data: "close" }
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // MEDIA FILTER
  // ============================================
  private static getMediaFilterUI(settings: any): UIComponent {
    const media = settings?.mediaRestrictions || {};
    const icon = (blocked: boolean) => blocked ? '‚úÖ' : '‚ùå';
    
    const message = `
üé¨ *Media Restrictions*

*Status:* ${media.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Currently Blocked:*
${icon(media.blockPhotos)} Photos
${icon(media.blockVideos)} Videos
${icon(media.blockStickers)} Stickers
${icon(media.blockGifs)} GIFs/Animations
${icon(media.blockDocuments)} Documents
${icon(media.blockLinks)} Links

*Commands:*
\`/media_toggle\` - Enable/Disable
\`/media_block photos\` - Block type
\`/media_allow photos\` - Allow type

*Types:* photos | videos | stickers | gifs | documents | links`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: media.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_media" }
        ],
        ...(media.enabled ? [
          [
            { text: `${icon(media.blockPhotos)} Photos`,
              callback_data: "tm_photos" },
            { text: `${icon(media.blockVideos)} Videos`,
              callback_data: "tm_videos" }
          ],
          [
            { text: `${icon(media.blockStickers)} Stickers`,
              callback_data: "tm_stickers" },
            { text: `${icon(media.blockGifs)} GIFs`,
              callback_data: "tm_gifs" }
          ],
          [
            { text: `${icon(media.blockDocuments)} Documents`,
              callback_data: "tm_docs" },
            { text: `${icon(media.blockLinks)} Links`,
              callback_data: "tm_links" }
          ]
        ] : []),
        [
          { text: "üîô Back", callback_data: "back_automod" },
          { text: "‚ùå Close", callback_data: "close" }
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // MULTI-JOIN
  // ============================================
  private static getMultiJoinUI(settings: any): UIComponent {
    const mj = settings?.multiJoinDetection || {};
    
    const message = `
üë• *Multi-Join Detection*

*Status:* ${mj.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Configuration:*
‚Ä¢ Max Groups: ${mj.maxGroupsInTime || 5}
‚Ä¢ Time Window: ${BotHelpers.formatDuration(mj.timeWindow || 3600)}
‚Ä¢ Action: ${mj.action?.toUpperCase() || 'REPORT'}
‚Ä¢ Auto Report: ${mj.autoReport ? '‚úÖ' : '‚ùå'}

*How it Works:*
If user joins ${mj.maxGroupsInTime || 5} groups within ${BotHelpers.formatDuration(mj.timeWindow || 3600)}, they will be ${mj.action || 'reported'}.

*Commands:*
\`/multijoin_toggle\` - Enable/Disable
\`/multijoin_limit 5\` - Set max groups
\`/multijoin_window 1h\` - Set time window`;

    const actionButtons = [
      { text: `${mj.action === 'warn' ? '‚úÖ' : ''} Warn`, callback_data: 'set_action_multijoin_warn' },
      { text: `${mj.action === 'kick' ? '‚úÖ' : ''} Kick`, callback_data: 'set_action_multijoin_kick' },
      { text: `${mj.action === 'ban' ? '‚úÖ' : ''} Ban`, callback_data: 'set_action_multijoin_ban' },
      { text: `${mj.action === 'report' ? '‚úÖ' : ''} Report`, callback_data: 'set_action_multijoin_report' }
    ];

    const keyboard = {
      inline_keyboard: [
        [
          { text: mj.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_multijoin" }
        ],
        actionButtons,
        [
          { text: mj.autoReport ? "‚ùå Disable Auto-Report" : "‚úÖ Enable Auto-Report",
            callback_data: "set_action_multijoin_autoreport" }
        ],
        [
          { text: "üîô Back to Auto-Mod", callback_data: "back_automod" }
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // WARNING SYSTEM
  // ============================================
  private static getWarningSystemUI(settings: any): UIComponent {
    const warn = settings?.warningSystem || {};
    const expiry = BotHelpers.formatDuration(warn.warningExpiry || 604800);
    
    const message = `
‚ö†Ô∏è *Warning System*

*Status:* ${warn.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Configuration:*
‚Ä¢ Max Warnings: ${warn.maxWarnings || 3}
‚Ä¢ Warning Expiry: ${expiry}
‚Ä¢ Action on Max: ${warn.actionOnMax?.toUpperCase() || 'BAN'}

*How it Works:*
1. Admin issues warning: \`/warn\`
2. User gets warned (1/${warn.maxWarnings || 3})
3. After ${warn.maxWarnings || 3} warnings ‚Üí ${warn.actionOnMax || 'banned'}
4. Warnings expire after ${expiry}

*Commands:*
\`/warn\` - Warn user (reply)
\`/warnings\` - View warnings (reply)
\`/clearwarnings\` - Clear (reply)
\`/warning_max 3\` - Set max warnings
\`/warning_expiry 7\` - Expiry (days)`;

    const actionButtons = [
      { text: `${warn.actionOnMax === 'mute' ? '‚úÖ' : ''} Mute`, callback_data: 'set_action_warnings_mute' },
      { text: `${warn.actionOnMax === 'kick' ? '‚úÖ' : ''} Kick`, callback_data: 'set_action_warnings_kick' },
      { text: `${warn.actionOnMax === 'ban' ? '‚úÖ' : ''} Ban`, callback_data: 'set_action_warnings_ban' }
    ];

    const keyboard = {
      inline_keyboard: [
        [
          { text: warn.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_warnings" }
        ],
        actionButtons,
        [
          { text: "üîô Back to Auto-Mod", callback_data: "back_automod" }
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // AUTO-DELETE
  // ============================================
  private static getAutoDeleteUI(settings: any): UIComponent {
    const del = settings?.autoDelete || {};
    const duration = BotHelpers.formatDuration(del.deleteAfter || 86400);
    
    const message = `
üóëÔ∏è *Auto-Delete Messages*

*Status:* ${del.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Configuration:*
‚Ä¢ Delete After: ${duration}
‚Ä¢ Exclude Admins: ${del.excludeAdmins ? 'Yes ‚úÖ' : 'No ‚ùå'}
‚Ä¢ Specific Users: ${del.specificUsers?.length || 0} users

*How it Works:*
Messages are automatically deleted after ${duration}.

*Use Case:*
Keep group clean by auto-deleting old messages.

‚ö†Ô∏è *Note:* Bot can only delete messages ‚â§48 hours old due to Telegram limitation.

*Commands:*
\`/autodelete_toggle\` - Enable/Disable
\`/autodelete_time 24\` - Hours (1-48)
\`/autodelete_exclude yes\` - Exclude admins

*Warning:* Use carefully! Messages will be permanently deleted.`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: del.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_autodelete" }
        ],
        [
          { text: "üîô Back to Auto-Mod", callback_data: "back_automod" }
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // REPORTS
  // ============================================
  private static getReportsUI(settings: any): UIComponent {
    const rep = settings?.reportSettings || {};
    
    const message = `
üì¢ *Report System*

*Status:* ${rep.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Configuration:*
‚Ä¢ Report Channel: ${rep.reportChannel || 'Not set'}
‚Ä¢ Auto Report Spam: ${rep.autoReportSpam ? 'Yes ‚úÖ' : 'No ‚ùå'}
‚Ä¢ Auto Report Banned Words: ${rep.autoReportBannedWords ? 'Yes ‚úÖ' : 'No ‚ùå'}
‚Ä¢ Notify Admins: ${rep.notifyAdmins ? 'Yes ‚úÖ' : 'No ‚ùå'}

*How it Works:*
1. Auto-mod detects violation
2. Report sent to channel
3. Admins notified
4. Action logged

*Report Includes:*
‚Ä¢ User info
‚Ä¢ Violation type
‚Ä¢ Group name
‚Ä¢ Timestamp
‚Ä¢ Action taken

*Commands:*
\`/report_toggle\` - Enable/Disable
\`/report_channel @channel\` - Set channel
\`/report_spam yes\` - Auto report spam

*Setup:*
1. Create private channel
2. Add bot as admin
3. Use \`/report_channel @yourchannel\``;

    const keyboard = {
      inline_keyboard: [
        [
          { text: rep.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_reports" }
        ],
        [
          { text: "üîô Back to Auto-Mod", callback_data: "back_automod" }
        ]
      ]
    };

    return { message, keyboard };
  }

  // ============================================
  // NEW USERS
  // ============================================
  private static getNewUsersUI(settings: any): UIComponent {
    const newUser = settings?.newUserRestrictions || {};
    const duration = BotHelpers.formatDuration(newUser.restrictDuration || 3600);
    const icon = (enabled: boolean) => enabled ? '‚úÖ' : '‚ùå';
    
    const message = `
üÜï *New User Restrictions*

*Status:* ${newUser.enabled ? '‚úÖ Enabled' : '‚ùå Disabled'}

*Configuration:*
‚Ä¢ Restrict Duration: ${duration}

*Permissions for New Users:*
${icon(newUser.canSendMessages)} Send Messages
${icon(newUser.canSendMedia)} Send Media
${icon(newUser.canSendStickers)} Send Stickers
${icon(newUser.canSendPolls)} Send Polls

*How it Works:*
When user joins, they are restricted for ${duration} with limited permissions.

*Use Case:*
Prevent new users from immediately spamming.

*Commands:*
\`/newuser_toggle\` - Enable/Disable
\`/newuser_duration 60\` - Duration (minutes)
\`/newuser_messages yes\` - Allow messages
\`/newuser_media no\` - Block media`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: newUser.enabled ? "‚ùå Disable" : "‚úÖ Enable", 
            callback_data: "toggle_newusers" }
        ],
        [
          { text: "üîô Back to Auto-Mod", callback_data: "back_automod" }
        ]
      ]
    };

    return { message, keyboard };
  }
}